<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  
  
  
    <meta name="description" content="Ain&#39;t no mountain high enough">
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <title>
    大数据技术课程复习 |
    
    Blog_JosephLZD</title>
  
    <link rel="shortcut icon" href="/favicon.ico">
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<script src="/js/pace.min.js"></script>

<meta name="generator" content="Hexo 4.1.1"></head>

<body>
<main class="content">
  <section class="outer">
  

<article id="post-大数据技术课程复习" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      大数据技术课程复习
    </h1>
  
  




      </header>
    

    
      <div class="article-meta">
        <a href="/2020/01/01/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E8%AF%BE%E7%A8%8B%E5%A4%8D%E4%B9%A0/" class="article-date">
  <time datetime="2020-01-01T05:27:35.000Z" itemprop="datePublished">2020-01-01</time>
</a>
        
      </div>
    

    
      
    <div class="tocbot"></div>





    

    <div class="article-entry" itemprop="articleBody">
      


      

      
        <p>本科的最后一门课——《大数据技术原理与应用》期末复习文档。</p>
<a id="more"></a>
<h1 id="大数据概述"><a href="#大数据概述" class="headerlink" title="大数据概述"></a>大数据概述</h1><ul>
<li>信息科技需要解决信息存储、信息传输和信息处理3个核心问题。</li>
<li>闪存可以作为永久存储设备，是一种新兴的半导体存储器。</li>
<li>数据和信息的区别：信息由数据的有序排列组合而成，传达给读者某个概念方法等；数据是构成信息的基本单位，离散数据无实际意义。</li>
<li>数据产生方式的3个变化阶段：运营式系统阶段、用户原创内容阶段、感知式系统阶段。</li>
<li>运营式依附于传统数据库（医院医疗系统），用户原创内容依附于互联网云存储（抖音），感知式依附于物联网（监控摄像头）。</li>
<li>大数据的发展历程：萌芽期、成熟期、大规模应用期。</li>
<li>什么是大数据？：4V——数据量大、数据类型繁多、处理速度快、价值密度低。</li>
<li>科学数据研究上的四种范式（4个阶段）：实验科学、理论科学、计算科学、数据密集型科学。</li>
<li>大数据对思维方式的影响：全样而非抽样，效率而非精准，相关而非因果。 大数据计算模式：①批处理计算，针对大规模数据 ②流计算，针对流数据<br>③图计算，针对大规模图结构数据 ④查询分析计算，大规模数据的存储管理和查询分析</li>
<li>什么是云计算？：云计算实现了通过网络提供可伸缩的、廉价的分布式计算能力，用户只需要在具备网络接入条件的地方，就可以随时随地获得所需的各种IT资源</li>
<li>云计算的服务模式：公有云、私有云、混合云。关键技术：虚拟化、分布式存储/计算、多租户</li>
<li>什么是物联网？物物相连的互联网，利用通信技术实现信息化和远程管理控制。</li>
<li>大数据、云计算和物联网的区别：大数据侧重于海量数据的存储、处理与分析；云计算旨在整合和优化各种IT资源，并通过网络以服务的方式提供给用户；物联网目标是实现物物相连。</li>
<li>大数据、云计算和物联网的联系：三者相辅相成。云计算的分布式存储管理系统和分布式并行处理框架为大数据存储和处理提供技术支持，而大数据是云计算的基础。物联网的传感器源源不断地产生大数据，也需要借助云计算和大数据技术。</li>
</ul>
<h1 id="Hadoop"><a href="#Hadoop" class="headerlink" title="Hadoop"></a>Hadoop</h1><ul>
<li>Hadoop特性：高可靠性 高效性 高可扩展性 高容错性 成本低 运行在Linux平台 支持多种编程语言</li>
<li>Hadoop生态系统/组成部件：HDFS分布式存储系统，MapReduce分布式计算框架，Hbase基于HDFS存储的分布式数据库，Zookeeper分布式协调服务。</li>
</ul>
<h1 id="分布式文件系统HDFS"><a href="#分布式文件系统HDFS" class="headerlink" title="分布式文件系统HDFS"></a>分布式文件系统HDFS</h1><ul>
<li>名称节点：负责文件和目录的创建、删除和重命名等，同时管理着数据节点和文件块的映射关系。<br>在存储时：名称节点分配存储位置，客户端把数据直接写入数据节点；<br>在读取时：客户端从名称节点获得数据节点和文件块的映射关系，从而访问相应文件块。</li>
<li>数据节点：负责数据的存储和读取，根据客户端或名称节点的调度进行数据存储和检索，并向名称节点定期发送自己存储的块的列表。</li>
<li>名称节点存储元数据（目录）在内存中；数据节点存储文件内容在磁盘 中。 HDFS将硬件出错作为常态而非异常。</li>
<li>HDFS实现目标：兼容廉价的硬件设备；流数据读写；大数据集；简单的文件类型（一次写入，多次读取）；强大的跨平台兼容性。</li>
<li>HDFS局限性：不适合低延迟数据访问；无法高效存储大量小文件（目录太大内存装不下）；不支持多用户写入及任意修改文件（只允许一个写入者，只允许追加写而非任意写）</li>
<li>HDFS采用“块”存储的好处：支持大规模文件存储；简化系统设计；适合数据备份。（降低寻址开销，但块不能过大否则影响MapReduce并行执行效率）<br>HDFS中的块比普通文件系统中的块要大很多。</li>
<li>名称节点分为FsImage和EditLog，FsImage用于维护文件系统树和元数据，EditLog记录了所有针对文件的创建、删除、重命名等操作。名称节点非持久化存储信息，而是启动时扫描数据节点重构。更新操作只写入EditLog。</li>
<li>第二名称节点：①实现EditLog与FsImage的合并操作（合并后，新FsImage替换旧FsImage，EditLog.new替换EditLog）②作为名称节点的“检查点”（相当于备份，但没有终次合并后的新数据，所以不是热备份）</li>
<li>HDFS体系结构：主从结构（1个名称节点-多个数据节点）。</li>
<li>客户端与名称节点：TCP/IP通信协议；名称节点与数据节点：数据节点协议；客户端与数据节点：RPC</li>
<li>HDFS体系结构的局限性：命名空间的限制；性能的瓶颈；隔离问题；集群可用性<h3 id="HDFS的存取原理"><a href="#HDFS的存取原理" class="headerlink" title="HDFS的存取原理"></a>HDFS的存取原理</h3></li>
<li>HDFS数据冗余存储：加快数据传输速度（多个客户端访问时）；容易检查数据错误；保证数据可靠性</li>
<li>HDFS数据存取策略：1.数据存放（每一文件块会被同时保存到3个地方，两个在同一个机架不同机器上，一个在不同机架上）2.数据读取（提供API确定数据块的机架ID）</li>
<li>数据复制（<strong>流水线</strong>复制：分包同时传输（并行处理） 最终每个节点都得到所有分包）</li>
<li>HDFS数据错误与恢复：1.名称节点出错（远程挂载备份+第二名称节点）</li>
<li>数据节点出错（定期检测“心跳”信号，若无则宕机，生成新的冗余副本）3.数据出错（校验）</li>
<li>HDFS读数据：FileSystem.open()-&gt;创建输入流DFSInputStream，远程调用名称节点获得数据节点的地址；read()-&gt;读取数据；close()关闭输入流。<br>HDFS写数据：FileSystem.create()-&gt;创建输出流DFSOutputStream，远程调用名称节点进行检查和添加文件；write()-&gt;向对应文件写入数据，分包流水线传输，客户端收到确认应答-&gt;close()关闭输出流。</li>
<li>分布式文件系统如何实现较高水平扩展？物理结构上由多个节点构成，分为名称节点和数据节点。</li>
</ul>
<h1 id="分布式数据库HBase"><a href="#分布式数据库HBase" class="headerlink" title="分布式数据库HBase"></a>分布式数据库HBase</h1><p>HBase是一个高可靠、高性能、面向列、可伸缩的分布式数据库，主要用来存储非结构化和半结构化的松散数据，数据存储借助Hadoop的HDFS。</p>
<ul>
<li>简述在Hadoop体系架构中HBase与其他组成部分的相互关系：利用MepReduce处理HBase中的海量数据；利用Zookeeper作协同服务；利用HDFS作为底层存储。</li>
<li>HBase与传统关系数据库的区别： 数据类型。传统关系数据库采用关系模型；HBase将数据存储为未经解释的二进制符号。<br>数据操作。关系数据库操作丰富，且可以外键关联多表；HBase操作简单，且只采用单表的主键查询，无法实现多表连接。<br>存储模式。关系数据库基于行存储；HBase基于列存储，可以降低I/O开销，支持大量并发用户查询，且同一列族的数据压缩比高。<br>数据索引。HBase只有一个索引——行键。 数据维护。HBase中更新操作会仍然保留数据旧版本。<br>可伸缩性。HBase这种分布式数据库可以灵活横向扩展，随硬件数量实现性能伸缩。</li>
<li>HBase的数据模型（+实例）：稀疏、多维度、排序的映射表，这张表的索引是行键、列族、列限定符、时间戳。每个值是一个未经解释的字符串，没有数据类型。<br>其实就可以把其看成一个键值数据库，键是四维坐标即[行键，列族，列限定符，时间戳]</li>
<li>概念视图上我们还是认为HBase与传统关系数据库形式一致，但物理视图Hbase会以列族为单位分别存放行键和时间戳。</li>
<li>面向列存储VS面向行存储 区别： 行式数据库采用NSM存储模型，一行被连续地存储在磁盘页中，主要适合小批量的数据处理。</li>
<li>列式数据库采用DSM存储模型，以列为单位进行存储，主要适合批量数据处理和即席查询。优点是降低I/O开销，支持大量并发用户查询。缺点是执行连接操作重构元祖代价高。</li>
<li>HBase三个功能组件： 库函数，链接到每个客户端<br>一个Master主服务器，管理和维护HBase表的分区信息，并把Region分配到可用的Region服务器上。（Zookeeper实时监控Region服务器状态通知给Master）<br>许多个Region服务器，处理来自客户端的读写请求。<br>注意：HBase客户端从不依赖Master而是借助于Zookeeper来获得Region的位置信息，所以客户端不和Master通信。</li>
<li>每个Region的默认大小是100~200MB，是HBase中负载均衡和数据分发的基本单位。</li>
<li>分区如何定位？Region标识符和Region服务器标识符。</li>
<li>.META.表：一张Region-Region服务器的映射表。若.META.表也分裂成多个Region，则再新建-ROOT-表来映射，注意-ROOT-表位置固定且不能分裂了。</li>
</ul>
<p>HBase的三层结构：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWd2aWRlb2ZvcmJsb2cub3NzLWNuLXNoYW5naGFpLmFsaXl1bmNzLmNvbS8lRTUlQTQlQTclRTYlOTUlQjAlRTYlOEQlQUUxLnBuZw?x-oss-process=image/format,png" alt="Alt"></p>
<ul>
<li>HBase客户端访问用户数据流程（三级寻址）：访问Zookeeper获取-ROOT-表位置信息，访问-ROOT-表获得.META.表的信息，访问.META.表，找到所需的Region所在的Region服务器，然后去读取数据。为了加快寻址速度，可直接访问客户端缓存。<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWd2aWRlb2ZvcmJsb2cub3NzLWNuLXNoYW5naGFpLmFsaXl1bmNzLmNvbS8lRTUlQTQlQTclRTYlOTUlQjAlRTYlOEQlQUUyLnBuZw?x-oss-process=image/format,png" alt="Alt"></li>
<li>Region服务器管理了一系列Region对象和一个HLog日志文件。每个Region对象由多个Store组成，每个Store对应一个列族的存储。每个Store包含一个MemStore（内存中的缓存，保存最近更新的数据）和多个StoreFile（磁盘中的文件）。</li>
<li>HBase读写数据是先写入MemStore和HLog，刷新缓存即将缓存内容写入磁盘StoreFile，每次刷新缓存生成一个StoreFile文件，之后把这多个StoreFile合并。</li>
<li>HStore工作原理/刷新缓存：每个Region服务器都有一个自己的HLog<br>文件，每次启动都检查该文件，确认最近一次执行缓存刷新操作之后是否发生新的写入操作；如果发现更新，则先写入MemStore，再刷写到StoreFile，最后删除旧的Hlog文件，开始为用户提供服务</li>
<li>HBase采用HLog来保证系统发生故障时能够恢复到正确状态，即“先写日志，再载数据”。</li>
<li>所有Region对象共用一个HLog！共用日志优点：提高对表的写操作性能；缺点：恢复时需要分拆日志。</li>
<li>HBase编程中，要先disable再drop（先使表无效再删除该表）。</li>
<li>添加某个值：InsertData(“student”,”zhangsan”,”score”,”English”,”69”);<br>HBase又可看成列族数据库，又可看成键值数据库。</li>
<li>当一台Region服务器意外终止，Master如何发现？为了恢复，Master如何处理？<br>Zookeeper实时监测Region服务器状态，若异常则通知Master；</li>
<li>Master首先处理该故障Region服务器上的HLog文件，拆分日志放到相应的region对象下，再将失效的region重新分配到可用的Region服务器，HLog也随之发送。Region服务器领取到后重做日志操作，写入MemStore，刷新缓存到StoreFile文件，完成恢复。</li>
</ul>
<h1 id="NoSQL"><a href="#NoSQL" class="headerlink" title="NoSQL"></a>NoSQL</h1><p>NoSQL的概念：非关系型数据库，采用键值、列族、文档、图等非关系模型。</p>
<ul>
<li><p>NoSQL数据库三大特点：①灵活的可扩展性（横向扩展）②灵活的数据模型（如键值、列族） ③与云计算紧密结合</p>
</li>
<li><p>NoSQL兴起的原因：（1）关系数据库无法满足Web2.0的需求：无法满足海量数据的管理需求；无法满足数据高并发的需求；无法满足高可扩展性和高可用性的需求。（2）关系数据库的关键特性在Web2.0时代成为“鸡肋”：Web2.0一般不要求严格的数据库事务和读写实时性，且不包含大量复杂的SQL查询。</p>
</li>
<li><p>NoSQL与关系数据库的比较：NoSQL的优势在于，可以支持超大规模数据存储，灵活的数据模型很好地支持Web2.0应用，具有强大的横向扩展能力；NoSQL劣势在于，缺乏数学理论基础，复杂查询性能不高，一般不能实现事务强一致性，很难实现数据完整性，技术尚不成熟等。</p>
</li>
<li><p>NoSQL数据库的四个经典类型：键值、列族、文档、图数据库。</p>
</li>
<li><p>键值数据库会使用一个哈希表，即Key-Value形式。键值数据库分为内存键值数据库和持久化键值数据库。（扩展性好，灵活性好，性能高，但无法存储结构化信息。）</p>
</li>
<li><p>列族数据库中，每行数据包含多个列族，不同的行可以具有不同数量的列族，属于同一列族的数据会被存放在一起。（查找速度块，但功能太少。）<br>文档数据库，文档是数据库的最小单位，文档数据库采用“key-文档”的形式，有点像键值数据库，但区别在于文档数据库不仅可用key构建索引，还可基于文档内容构建索引，而键值数据库中的value对数据库透明不可见，不可作索引。（缺乏统一的查询语法）</p>
</li>
<li><p>图数据库，专门用于处理具有高度相互关联关系的数据。（高效处理实体之间的关系，但复杂度高，只能支持一定的数据规模。）</p>
</li>
<li><p>NoSQL的三大基石：CAP、BASE、最终一致性。</p>
</li>
<li><p>CAP：C是一致性，A是可用性，P是分区容忍性。C指读操作总是读到最后一次写操作的结果；A是指快速获取数据，实时性；P是指系统中某部分无法通信，系统仍能正常工作。<br>三者只能选其二！书上的例子是说牺牲一致性来换取可用性，P1写入V1的数据还没传给副本V2，P2就从V2把旧数据读走了。<br>mySQL和SQLServer都是选择CA放弃P<br>对于Web2.0网站来说，可用性A与容忍性P的优先级要高于数据一致性C。</p>
</li>
<li><p>BASE：基本可用、软状态、最终一致性。 基本可用：一个分布式系统的一部分出现问题，其他部分仍可以正常使用。<br>软状态：数据并非一直是正确且同步的，而是允许可以有时间滞后。<br>最终一致性：是弱一致性的一种特例，指数据更新后可能要一段时间才能读到最新数据，但最终一定可以读到最新数据。<br>最终一致性：几个特殊情况：因果一致性（进程A更新数据且通知了进程B，则进程B访问会是最新数据），“读己之所写“一致性（自己更新肯定自己后续访问到的是最新），会话一致性（放到会话里也一致），单调读一致性（再次读不会读到旧值），单调写一致性（写操作顺序执行）。<br>对于最终一致性而言，从写入操作完成后到后续访问可以读取到该写入的最新值，这之间的时间间隔称为“不一致性窗口”。</p>
</li>
<li><p>NoSQL肯定不支持复杂查询，且不支持事务ACID四性。<br>NewSQL结合了NoSQL的海量数据存储管理能力和传统数据库的SQL和ACID特性。</p>
</li>
</ul>
<h1 id="云数据库"><a href="#云数据库" class="headerlink" title="云数据库"></a>云数据库</h1><p>云计算的概念：云计算是由一系列可以动态升级和被虚拟化的资源组成的，用户无需掌握云计算的技术，只要通过网络就可以访问这些资源。</p>
<ul>
<li>云计算分为3种类型：IaaS、PaaS、SaaS</li>
<li>云数据库的概念：云数据库是部署和虚拟化在云计算环境中的数据库，允许用户以服务的方式通过网络获得云端的数据库功能。</li>
<li>云数据库的优势/特性：动态可扩展；高可用性；较低的使用代价；易用性；高性能；免维护；安全。</li>
<li>对于企业来说，云数据库可以满足大企业的海量数据存储需求，可以满足中小企业的低成本数据存储需求，也可以满足企业动态变化的数据存储需求。但考虑安全性，不是说一定要放到云数据库上才好。</li>
<li>云数据库并非一种专门的数据库类型，而是将数据库配置到云端，可以是文档数据库MongoDB，也可以是键值数据库Redis。</li>
<li>市场上的云数据库举例：微软SQL Azure，阿里云RDS，亚马逊AWS<br>UMP系统功能：容灾、读写分离、分库分表、资源管理、资源调度、资源隔离、数据安全。</li>
<li>UMP系统中的角色：Controller服务器（管理UMP集群）、Web控制台、Proxy服务器（Mysql访问接口）、Agent服务器（管理MySQL实例）、日志分析服务器、信息分析服务器、愚公系统（增量复制，实现动态扩容缩容和迁移）。</li>
<li>UMP依赖的开源组件：Mnesia（分布式数据库管理系统）、RabbitMQ（消息队列）、Zookeeper（协同工作系统）、LVS（Linux虚拟服务器）。<br>UMP主从备份：主库和从库的状态由Zookeeper维护，检测到宕机则通知给controller服务器实施主从切换。</li>
<li>UMP读写分离：写操作直接发送到主库，读操作则均衡地发送到主库和从库，实现读写分离、负载均衡。为了避免从从库读到旧数据，写操作后会有计时器，一定时间内则只从主库读。</li>
<li>UMP资源隔离方式：用Cgroup限制MySQL进程资源；在Proxy服务器限制QPS。</li>
<li>UMP数据安全保障机制：SSL数据库连接；数据访问IP白名单；记录用户操作日志；SQL拦截。</li>
</ul>
<h1 id="MapReduce"><a href="#MapReduce" class="headerlink" title="MapReduce"></a>MapReduce</h1><ul>
<li>MapReduce概念：分布式并行编程框架，将存储在分布式文件系统中的大规模数据集切分成许多独立的小数据块，被MapReduce并行处理。<br><strong>适用前提</strong>：待处理的数据集可以分解成许多小的数据集，且并行处理。</li>
<li>分片VS分块：分片是逻辑上的自行划分；分块是为了物理上的冗余备份，块大小固定。</li>
<li>MapReduce理念“计算向数据靠拢”，即将计算结点和存储结点放在一起运行。 MapReduce策略“分而治之”。</li>
<li>注意，在Map任务之间、在Reduce任务之间不会发生任何通信。当Map处理全部结束后才开始Reduce。只有Map需要考虑数据局部性。输入文件和Reduce输出都存在HDFS分布式文件系统中。</li>
<li>MapReduce框架采用了Master/Slave架构，包括一个Master和若干个Slave。Master上运行JobTracker，Slave上运行TaskTracker<br>Hadoop框架是用Java实现的，但是，MapReduce应用程序则不一定要用Java来写 。<br>MapReduce体系结构：Client、JobTracker、TaskTracker、Task</li>
</ul>
<p>论述MapReduce工作流程（画图）：①首先做Map前的预处理。MapReduce将输入文件分片成多个InputSplit，RR以此加载数据并转换成适合Map任务读取的键值对，输入给Map。②Map输出一系列&lt;k,v&gt;作为中间结果。③Shuffle过程对中间结果进行溢写（分区排序合并）和归并。④Reduce领取输入，执行用户定义的逻辑，输出结果。<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWd2aWRlb2ZvcmJsb2cub3NzLWNuLXNoYW5naGFpLmFsaXl1bmNzLmNvbS8lRTUlQTQlQTclRTYlOTUlQjAlRTYlOEQlQUUzLnBuZw?x-oss-process=image/format,png" alt="Alt"></p>
<ul>
<li><p>描述MapReduce中JobTracker和TaskTracker的功能：MapReduce采用Master(JobTracker)-Slave(TaskTracker)结构。JobTracker负责作业和任务的调度，监控它们的执行，重新调度已失败的任务；TaskTracker负责执行由JobTracker指派的任务。</p>
</li>
<li><p>是否所有的MapReduce程序都需要经过Map和Reduce这两个过程？不是！对于关系的选择运算，只需要Map过程就能实现。输出的键值对是&lt;t,t&gt;。</p>
</li>
<li><p>Shuffle过程详解：shuffle是个中间衔接过程，对Map输出的中间结果进行分区、排序、合并等处理交给Reduce的过程，又分为Map端和Reduce端的Shuffle。<br>Map端的Shuffle：Map输出的中间结果写入缓存，若满则“溢写”（分区、排序和合并），对多次溢写产生的文件进行归并。<br>Reduce端的Shuffle：先领取数据，由于数据来自不同的Map机器，可以继续同理“溢写”+归并，最后把多个大文件直接输入给Reduce任务。<br>合并和归并的区别：两个键值对&lt;“a”,1&gt;和&lt;“a”,1&gt;，如果合并，会得到&lt;“a”,2&gt;，如果归并，会得到&lt;“a”,&lt;1,1&gt;&gt;</p>
</li>
</ul>
<p>重要的一道例题<strong>WordCount</strong> 统计单词出现频数。左边是Map过程，右边是Reduce过程。<br>注意！（1）合并：右边图是Shuffle未定义Combiner时的Reduce过程，若定义了Combiner则是&lt;World,2&gt;而非&lt;World,&lt;1,1&gt;&gt;。（2）排序：Shuffle结果还要注意按字典序对键值对排序！<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWd2aWRlb2ZvcmJsb2cub3NzLWNuLXNoYW5naGFpLmFsaXl1bmNzLmNvbS8lRTUlQTQlQTclRTYlOTUlQjAlRTYlOEQlQUU0LnBuZw?x-oss-process=image/format,png" alt="Alt"><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWd2aWRlb2ZvcmJsb2cub3NzLWNuLXNoYW5naGFpLmFsaXl1bmNzLmNvbS8lRTUlQTQlQTclRTYlOTUlQjAlRTYlOEQlQUU1LnBuZw?x-oss-process=image/format,png" alt="Alt"></p>
<p><strong>关系的自然连接运算</strong>：Map需要构建新的键值对形式，首先找到公共字段，以该公共字段的值作为key，而value是”关系名”,(其他字段的值)。即生成&lt;b,&lt;R,a&gt;&gt;。然后给Reduce归并，注意归并结果键值对不再包含关系名（关系名只是为了归并时作识别，不要同表里归并了）。如：<br>注意还是要对key排序的哈。<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWd2aWRlb2ZvcmJsb2cub3NzLWNuLXNoYW5naGFpLmFsaXl1bmNzLmNvbS8lRTUlQTQlQTclRTYlOTUlQjAlRTYlOEQlQUU2LnBuZw?x-oss-process=image/format,png" alt="Alt"></p>
<ul>
<li>MapReduce可以应用的计算问题（前后项无关联）：关系代数、分组与聚合、矩阵-向量乘法、矩阵乘法。<strong><em>所以不能是递归、求斐波那契数列这种问题</em></strong>。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/01/01/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E8%AF%BE%E7%A8%8B%E5%A4%8D%E4%B9%A0/" data-id="ck4uv472d00005z6c9qhf015m"
         class="article-share-link">Share</a>
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AF%BE%E7%A8%8B%E5%A4%8D%E4%B9%A0/" rel="tag">课程复习</a></li></ul>

    </footer>

  </div>

  
    
  <nav class="article-nav">
    
    
      <a href="/2019/12/25/%E3%80%90%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E3%80%91%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF/" class="article-nav-link">
        <strong class="article-nav-caption">Olde posts</strong>
        <div class="article-nav-title">【统计学习方法】朴素贝叶斯</div>
      </a>
    
  </nav>


  

  
    
  <div class="gitalk" id="gitalk-container"></div>
  
<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">

  
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

  
<script src="https://cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.min.js"></script>

  <script type="text/javascript">
    var gitalk = new Gitalk({
      clientID: 'dd9dd0a01eb6aea2b4b2',
      clientSecret: 'f10df8d5a64e14405c16d484ff17f526f1ff2c21',
      repo: 'gitalk_blog',
      owner: 'JosephLZD',
      admin: ['JosephLZD'],
      // id: location.pathname,      // Ensure uniqueness and length less than 50
      id: md5(location.pathname),
      distractionFreeMode: false,  // Facebook-like distraction free mode
      pagerDirection: 'last'
    })

  gitalk.render('gitalk-container')
  </script>

  

</article>



</section>
  <footer class="footer">
  <div class="outer">
    <div class="float-right">
      <ul class="list-inline">
  
    <li><i class="fe fe-smile-alt"></i> <span id="busuanzi_value_site_uv"></span></li>
  
</ul>
    </div>
    <ul class="list-inline">
      <li>&copy; 2020 Blog_JosephLZD</li>
      <li>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></li>
    </ul>
  </div>
</footer>

</main>

<aside class="sidebar sidebar-specter">
  
    <button class="navbar-toggle"></button>
<nav class="navbar">
  
    <div class="logo">
      <a href="/"><img src="/images/hexo.svg" alt="Blog_JosephLZD"></a>
    </div>
  
  <ul class="nav nav-main">
    
      <li class="nav-item">
        <a class="nav-item-link" href="/">Home</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/archives">Archive</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/gallery">Gallery</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/about">About</a>
      </li>
    
    <li class="nav-item">
      <a class="nav-item-link nav-item-search" title="搜索">
        <i class="fe fe-search"></i>
        Search
      </a>
    </li>
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      <div class="totop" id="totop">
  <i class="fe fe-rocket"></i>
</div>
    </li>
    <li class="nav-item">
      
        <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
          <i class="fe fe-feed"></i>
        </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
  </aside>
  
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/jquery.justifiedGallery.min.js"></script>


<script src="/js/lazyload.min.js"></script>


<script src="/js/busuanzi-2.3.pure.min.js"></script>


  
<script src="/fancybox/jquery.fancybox.min.js"></script>




  
<script src="/js/tocbot.min.js"></script>

  <script>
    // Tocbot_v4.7.0  http://tscanlin.github.io/tocbot/
    tocbot.init({
      tocSelector: '.tocbot',
      contentSelector: '.article-entry',
      headingSelector: 'h1, h2, h3, h4, h5, h6',
      hasInnerContainers: true,
      scrollSmooth: true,
      positionFixedSelector: '.tocbot',
      positionFixedClass: 'is-position-fixed',
      fixedSidebarOffset: 'auto',
    });
  </script>



<script src="/js/ocean.js"></script>


</body>
</html>